<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AGI Explorer - Test Suite</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@400;500;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        .test-panel {
            position: fixed;
            top: 80px;
            right: 20px;
            background-color: var(--card-bg);
            padding: 20px;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            z-index: 1000;
            max-width: 400px;
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .test-panel h2 {
            margin-top: 0;
            color: var(--primary-color);
            margin-bottom: 15px;
        }
        
        .test-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .test-log {
            background-color: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 4px;
            font-family: 'Space Mono', monospace;
            font-size: 0.8rem;
            height: 250px;
            overflow-y: auto;
            margin-bottom: 15px;
        }
        
        .test-log-entry {
            margin-bottom: 5px;
            line-height: 1.4;
        }
        
        .test-log-entry.success {
            color: #10b981;
        }
        
        .test-log-entry.error {
            color: #ef4444;
        }
        
        .test-log-entry.info {
            color: #6366f1;
        }
        
        .test-summary {
            background-color: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 4px;
        }
        
        .test-summary h3 {
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1rem;
        }
        
        .test-summary ul {
            margin: 0;
            padding-left: 20px;
        }
        
        .test-summary li {
            margin-bottom: 5px;
        }
        
        .test-summary .passed {
            color: #10b981;
        }
        
        .test-summary .failed {
            color: #ef4444;
        }
        
        .test-item {
            margin-bottom: 10px;
        }
        
        .test-checkbox {
            margin-right: 8px;
        }
        
        .progress-bar {
            height: 6px;
            background-color: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-bottom: 15px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background-color: var(--primary-color);
            width: 0%;
            transition: width 0.3s ease;
        }
    </style>
</head>
<body>
    <!-- Include the original index.html content in an iframe -->
    <iframe src="index.html" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; border: none;"></iframe>
    
    <!-- Test Panel -->
    <div class="test-panel">
        <h2>AGI Explorer Test Suite</h2>
        
        <div class="progress-bar">
            <div class="progress-fill" id="testProgress"></div>
        </div>
        
        <div class="test-controls">
            <button id="runAllTests" class="primary-button">Run All Tests</button>
            <button id="runSelectedTests" class="secondary-button">Run Selected</button>
            <button id="clearLog" class="secondary-button">Clear Log</button>
        </div>
        
        <div class="test-selection">
            <div class="test-item">
                <input type="checkbox" id="testBrainViz" class="test-checkbox" checked>
                <label for="testBrainViz">Brain Visualization</label>
            </div>
            <div class="test-item">
                <input type="checkbox" id="testGlitchEffect" class="test-checkbox" checked>
                <label for="testGlitchEffect">Glitch Effect</label>
            </div>
            <div class="test-item">
                <input type="checkbox" id="testNavLinks" class="test-checkbox" checked>
                <label for="testNavLinks">Navigation Links</label>
            </div>
            <div class="test-item">
                <input type="checkbox" id="testSimControls" class="test-checkbox" checked>
                <label for="testSimControls">Simulation Controls</label>
            </div>
            <div class="test-item">
                <input type="checkbox" id="testSimExecution" class="test-checkbox" checked>
                <label for="testSimExecution">Simulation Execution</label>
            </div>
            <div class="test-item">
                <input type="checkbox" id="testPopup" class="test-checkbox" checked>
                <label for="testPopup">Popup Functionality</label>
            </div>
        </div>
        
        <h3 style="margin-top: 15px; margin-bottom: 5px;">Test Log</h3>
        <div class="test-log" id="testLog">
            <div class="test-log-entry info">Test suite initialized. Select tests and click "Run" to begin testing.</div>
        </div>
        
        <div class="test-summary" id="testSummary">
            <h3>Test Summary</h3>
            <p>No tests have been run yet.</p>
        </div>
    </div>
    
    <script>
        // Test suite functionality
        document.addEventListener('DOMContentLoaded', function() {
            const iframe = document.querySelector('iframe');
            const runAllTestsBtn = document.getElementById('runAllTests');
            const runSelectedTestsBtn = document.getElementById('runSelectedTests');
            const clearLogBtn = document.getElementById('clearLog');
            const testLog = document.getElementById('testLog');
            const testSummary = document.getElementById('testSummary');
            const testProgress = document.getElementById('testProgress');
            
            // Test definitions
            const tests = [
                {
                    id: 'testBrainViz',
                    name: 'Brain Visualization',
                    run: testBrainVisualization
                },
                {
                    id: 'testGlitchEffect',
                    name: 'Glitch Effect',
                    run: testGlitchEffect
                },
                {
                    id: 'testNavLinks',
                    name: 'Navigation Links',
                    run: testNavigationLinks
                },
                {
                    id: 'testSimControls',
                    name: 'Simulation Controls',
                    run: testSimulationControls
                },
                {
                    id: 'testSimExecution',
                    name: 'Simulation Execution',
                    run: testSimulationExecution
                },
                {
                    id: 'testPopup',
                    name: 'Popup Functionality',
                    run: testPopupFunctionality
                }
            ];
            
            // Log function
            function log(message, type = 'info') {
                const entry = document.createElement('div');
                entry.className = `test-log-entry ${type}`;
                entry.textContent = message;
                testLog.appendChild(entry);
                testLog.scrollTop = testLog.scrollHeight;
            }
            
            // Clear log
            clearLogBtn.addEventListener('click', function() {
                testLog.innerHTML = '';
                log('Log cleared.', 'info');
            });
            
            // Run all tests
            runAllTestsBtn.addEventListener('click', function() {
                // Check all checkboxes
                tests.forEach(test => {
                    document.getElementById(test.id).checked = true;
                });
                
                runTests();
            });
            
            // Run selected tests
            runSelectedTestsBtn.addEventListener('click', function() {
                runTests();
            });
            
            // Main test runner function
            async function runTests() {
                log('Starting test run...', 'info');
                
                // Get selected tests
                const selectedTests = tests.filter(test => 
                    document.getElementById(test.id).checked
                );
                
                if (selectedTests.length === 0) {
                    log('No tests selected!', 'error');
                    return;
                }
                
                log(`Running ${selectedTests.length} tests...`, 'info');
                
                // Wait for iframe to load
                if (iframe.contentDocument.readyState !== 'complete') {
                    log('Waiting for page to load...', 'info');
                    await new Promise(resolve => {
                        iframe.addEventListener('load', resolve, { once: true });
                    });
                }
                
                // Reset progress bar
                testProgress.style.width = '0%';
                
                // Results object
                const results = {
                    passed: 0,
                    failed: 0,
                    total: selectedTests.length,
                    testResults: []
                };
                
                // Run each test sequentially
                for (let i = 0; i < selectedTests.length; i++) {
                    const test = selectedTests[i];
                    log(`Running test: ${test.name}`, 'info');
                    
                    try {
                        // Update progress
                        testProgress.style.width = `${(i / selectedTests.length) * 100}%`;
                        
                        // Run the test with timeout
                        const result = await runWithTimeout(test.run, 5000);
                        
                        if (result) {
                            results.passed++;
                            log(`✅ ${test.name}: PASSED`, 'success');
                        } else {
                            results.failed++;
                            log(`❌ ${test.name}: FAILED`, 'error');
                        }
                        
                        results.testResults.push({
                            name: test.name,
                            status: result ? 'PASSED' : 'FAILED',
                            error: null
                        });
                    } catch (error) {
                        results.failed++;
                        log(`❌ ${test.name}: ERROR - ${error.message}`, 'error');
                        
                        results.testResults.push({
                            name: test.name,
                            status: 'ERROR',
                            error: error.message
                        });
                    }
                    
                    // Small delay between tests
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Complete progress bar
                testProgress.style.width = '100%';
                
                // Update test summary
                updateTestSummary(results);
                
                log(`Test run completed. ${results.passed} passed, ${results.failed} failed.`, 
                    results.failed === 0 ? 'success' : 'error');
            }
            
            // Run a function with timeout
            function runWithTimeout(fn, timeout) {
                return new Promise((resolve, reject) => {
                    // Set timeout
                    const timeoutId = setTimeout(() => {
                        reject(new Error("Test timed out"));
                    }, timeout);
                    
                    // Run the function
                    try {
                        const result = fn();
                        
                        // Handle if the function returns a promise
                        if (result instanceof Promise) {
                            result
                                .then(value => {
                                    clearTimeout(timeoutId);
                                    resolve(value);
                                })
                                .catch(error => {
                                    clearTimeout(timeoutId);
                                    reject(error);
                                });
                        } else {
                            clearTimeout(timeoutId);
                            resolve(result);
                        }
                    } catch (error) {
                        clearTimeout(timeoutId);
                        reject(error);
                    }
                });
            }
            
            function updateTestSummary(results) {
                // Create summary HTML
                let summaryHTML = `<h3>Test Summary</h3>`;
                
                if (results.total === 0) {
                    summaryHTML += `<p>No tests were run.</p>`;
                } else {
                    const successRate = Math.round((results.passed / results.total) * 100);
                    
                    summaryHTML += `
                        <p>${results.passed} of ${results.total} tests passed (${successRate}%).</p>
                        <ul>
                    `;
                    
                    results.testResults.forEach(test => {
                        const statusClass = test.status === 'PASSED' ? 'passed' : 'failed';
                        summaryHTML += `<li class="${statusClass}">${test.name}: ${test.status}</li>`;
                    });
                    
                    summaryHTML += `</ul>`;
                }
                
                testSummary.innerHTML = summaryHTML;
            }
            
            // Test implementation functions
            function testBrainVisualization() {
                const iframeDocument = iframe.contentDocument;
                
                const brainContainer = iframeDocument.getElementById('brainVisualization');
                if (!brainContainer) {
                    log('Brain visualization container not found', 'error');
                    return false;
                }
                
                const neurons = brainContainer.querySelectorAll('.neuron');
                const connections = brainContainer.querySelectorAll('.connection');
                
                if (neurons.length === 0) {
                    log('No neurons found in brain visualization', 'error');
                    return false;
                }
                
                if (connections.length === 0) {
                    log('No connections found in brain visualization', 'error');
                    return false;
                }
                
                log(`Found ${neurons.length} neurons and ${connections.length} connections`, 'info');
                return true;
            }
            
            function testGlitchEffect() {
                const iframeDocument = iframe.contentDocument;
                
                const glitchText = iframeDocument.querySelector('.glitch-text');
                if (!glitchText) {
                    log('Glitch text element not found', 'error');
                    return false;
                }
                
                // Check if the glitch text has the correct data attribute
                if (glitchText.getAttribute('data-text') !== glitchText.textContent) {
                    log('Glitch text data-text attribute doesn\'t match content', 'error');
                    return false;
                }
                
                // Trigger glitch effect manually
                glitchText.classList.add('glitching');
                
                // Check if the glitch effect is applied
                const hasGlitchEffect = window.getComputedStyle(glitchText).getPropertyValue('position') === 'relative';
                
                // Clean up
                setTimeout(() => {
                    glitchText.classList.remove('glitching');
                }, 200);
                
                return hasGlitchEffect;
            }
            
            function testNavigationLinks() {
                const iframeDocument = iframe.contentDocument;
                
                const navLinks = iframeDocument.querySelectorAll('.nav-links a');
                if (navLinks.length === 0) {
                    log('No navigation links found', 'error');
                    return false;
                }
                
                // Check if all links have href attributes that point to sections
                let allValid = true;
                let validCount = 0;
                
                navLinks.forEach(link => {
                    const href = link.getAttribute('href');
                    if (!href || !href.startsWith('#') || !iframeDocument.querySelector(href)) {
                        log(`Invalid navigation link: ${href}`, 'error');
                        allValid = false;
                    } else {
                        validCount++;
                    }
                });
                
                log(`Found ${validCount} valid navigation links out of ${navLinks.length}`, 'info');
                return allValid;
            }
            
            function testSimulationControls() {
                const iframeDocument = iframe.contentDocument;
                
                // Check if all simulation controls exist
                const controls = [
                    'learningRate',
                    'networkSize',
                    'taskComplexity',
                    'taskDomain',
                    'runSimulation',
                    'resetSimulation'
                ];
                
                let allControlsExist = true;
                let missingControls = [];
                
                controls.forEach(controlId => {
                    const control = iframeDocument.getElementById(controlId);
                    if (!control) {
                        missingControls.push(controlId);
                        allControlsExist = false;
                    }
                });
                
                if (missingControls.length > 0) {
                    log(`Missing controls: ${missingControls.join(', ')}`, 'error');
                    return false;
                }
                
                // Test range input value display
                const learningRateInput = iframeDocument.getElementById('learningRate');
                const learningRateValue = iframeDocument.getElementById('learningRateValue');
                
                if (!learningRateValue) {
                    log('Learning rate value display not found', 'error');
                    return false;
                }
                
                const initialValue = learningRateInput.value;
                const testValue = "0.05";
                learningRateInput.value = testValue;
                
                // Dispatch input event
                const event = new Event('input');
                learningRateInput.dispatchEvent(event);
                
                // Check if value display was updated
                const valueUpdated = learningRateValue.textContent === testValue;
                
                // Reset to initial value
                learningRateInput.value = initialValue;
                learningRateInput.dispatchEvent(event);
                
                if (!valueUpdated) {
                    log('Learning rate value display not updating correctly', 'error');
                    return false;
                }
                
                return true;
            }
            
            function testSimulationExecution() {
                const iframeDocument = iframe.contentDocument;
                
                // Get simulation controls
                const learningRateInput = iframeDocument.getElementById('learningRate');
                const networkSizeInput = iframeDocument.getElementById('networkSize');
                const taskComplexityInput = iframeDocument.getElementById('taskComplexity');
                const taskDomainSelect = iframeDocument.getElementById('taskDomain');
                const runButton = iframeDocument.getElementById('runSimulation');
                
                if (!learningRateInput || !networkSizeInput || !taskComplexityInput || 
                    !taskDomainSelect || !runButton) {
                    log('Simulation controls not found', 'error');
                    return false;
                }
                
                // Set test values
                learningRateInput.value = "0.05";
                networkSizeInput.value = "7";
                taskComplexityInput.value = "3";
                taskDomainSelect.value = "reasoning";
                
                // Trigger input events
                const event = new Event('input');
                learningRateInput.dispatchEvent(event);
                networkSizeInput.dispatchEvent(event);
                taskComplexityInput.dispatchEvent(event);
                
                // Clear previous visualization
                const simulationViz = iframeDocument.getElementById('simulationVisualization');
                simulationViz.innerHTML = '';
                
                // Run the simulation
                runButton.click();
                
                // Check if visualization was created (after a short delay)
                return new Promise(resolve => {
                    setTimeout(() => {
                        const networkLayers = simulationViz.querySelectorAll('.network-layer');
                        const networkNeurons = simulationViz.querySelectorAll('.network-neuron');
                        const networkConnections = simulationViz.querySelectorAll('.network-connection');
                        
                        if (networkLayers.length === 0 || networkNeurons.length === 0 || networkConnections.length === 0) {
                            log('Network visualization not created properly', 'error');
                            resolve(false);
                        } else {
                            log(`Simulation created ${networkLayers.length} layers, ${networkNeurons.length} neurons, ${networkConnections.length} connections`, 'info');
                            resolve(true);
                        }
                    }, 1000);
                });
            }
            
            function testPopupFunctionality() {
                const iframeDocument = iframe.contentDocument;
                
                const simulateBtn = iframeDocument.getElementById('simulateBtn');
                const simulationPopup = iframeDocument.getElementById('simulationPopup');
                const closePopup = iframeDocument.getElementById('closePopup');
                
                if (!simulateBtn || !simulationPopup || !closePopup) {
                    log('Simulation popup elements not found', 'error');
                    return false;
                }
                
                // Test opening popup
                simulateBtn.click();
                
                // Check if popup is displayed
                const isDisplayed = window.getComputedStyle(simulationPopup).display === 'flex';
                
                if (!isDisplayed) {
                    log('Popup did not open when button was clicked', 'error');
                    return false;
                }
                
                // Test closing popup
                closePopup.click();
                
                // Check if popup is hidden after a short delay
                return new Promise(resolve => {
                    setTimeout(() => {
                        const isHidden = window.getComputedStyle(simulationPopup).display === 'none';
                        if (!isHidden) {
                            log('Popup did not close properly', 'error');
                            resolve(false);
                        } else {
                            log('Popup opened and closed successfully', 'success');
                            resolve(true);
                        }
                    }, 300);
                });
            }
        });
    </script>
</body>
</html>